const id = "reference/indicators_custom.md";
						const collection = "docs";
						const slug = "reference/indicators_custom";
						const body = "\nDevelopers are not restricted to using only the [default indicators](../indicators_default) provided by TradeX-chart. After all, everybody has their own secret methods for finding signals in the market.\n\n:::note\nPlease first read the [Indicators](../indicators) documentation before proceeding with custom indicators, as the later extends the former and inherits the bulk of it's properties, methods and functionality from it.\n:::\n\nIf you examine the repo for the ``Indicator`` class ``./src/components/overlays/indicator.js`` you will note that the Indicator class itself extends the ``Overlay`` class ``./src/components/overlays/overlay.js`` which provides all of the methods for it to be rendered to the chart pane in the render loop. It also provides the canvas for your indicator to draw on.\n\n### Registering Custom Indicators\n\nBefore any custom indicator can be used, it first must be registered with the chart.\n\nDuring the registration of custom indicators, there is the option to expunge all of the default indicators, thereby allowing the developer to replace them all, or select which to keep.\n\n```javascript\n// custom indicator class\nimport TEST from \"testIndicator\"\n\n/**\n * set indicators\n * @param {Object} i - indicators {id, name, event, ind}\n * @param {boolean} flush - expunge default indicators\n * @returns boolean\n */\nchart.setIndicators({\n  TEST: {id: \"TEST\", name: \"Custom Indicator\", event: \"addIndicator\", ind: TEST}, false\n})\n```\n\nThe list of registered indicators, both default and custom can be accessed via the chart API.\n\n```javascript\n// returns a Map() iterator of indicators\nconst primaryPaneIndicators = chart.Indicators.primary.entries()\nconst secondaryPaneIndicators = chart.Indicators.secondary.entries()\n```\n\n### Indicator Definitions\n\n#### Local Y-Axis Range\n\nIf the indicator is not overlaid on the Primary Chart Pane, and instead on a Secondary Chart Pane, there is the option to set the local Y-Axis range, min and max values which will be used for the scale and plotting the indicator.\n\n```javascript\nthis.chart.setLocalRange(0, 150)\n```\n\n#### Legend\n\nEach [indicator](../legends) has a legend to display it's information. The legend also provides a simple GUI of icons to modify the indicator.\n\nIndicators must provide a ``legendInputs(pos)`` method. The chart will pass the current mouse position to the indicator in an array, ``[x, y]``.\n\nLegends can display multiple values if formatted correctly.\n\nIf the indicator provides no values for it's legend then simply return false.\n\n```javascript\nlegendInputs() {\n  return false;\n}\n```\n\nWhen the indicator does provide values for it's legend, then the `legendInputs()` method must return an object with three entries.\n\n```javascript\n return {inputs, colours, labels}\n```\n\nwhere the three entries are defined as the following:\n\n```javascript\n/**\n  @param {Object} inputs - property names are used as labels\n  @param {Array} colours - array of #rrggbb(aa) values\n  @param {Array} labels - array of which input labels to dispaly [true, false, ...]\n*/\n```\n\n##### inputs\n\nis an object that provides the legend labels and values.\nFor example the Bollinger Band indicator has three values. It's returned ``inputs`` object would look like the following:\n\n```javascript\n{ Hi: \"13016.1\", Mid: \"13011.2\", Lo: \"13006.2\" }\n```\n\nThe object property names are used as the labels for the indicator.\nThe Bollinger Band indicator legend would look like this on the chart:\n\n```javascript\n Hi: 13016.1  Mid: 13011.2  Lo: 13006.2\n```\n\nIf you wanted a label with spaces, then the object property name would have to be quoted. ``\"some value\": 12345``\n\n##### colours\n\nis an array of ``\"#rrggbb(aa)\"`` string values corresponding to the legend values\n\n##### lables\n\nis an array that specifies which of the legend labels are displayed.\nIn the Bollinger Band example, if you wanted to silence all labels, use an array of ``[false, false, false]``.\n\n#### Canvas Drawing Methods\n\nThe base ``Indicator`` class which all others, including custom indicators are built atop, offers the ``plot()`` method for drawing to the canvas.\n\nThe ``Indicator`` class also exposes a pointer to the canvas directly, so you could also use your own functions instead.\n\nRefer to the [Canvas Methods documentation](../canvas_mehtods) for the available functions.\n\n```javascript\nthis.plot (plots, type, opts )\n```\n\n\n| Parameters | Type   | Description                                       |\n| ------------ | -------- | --------------------------------------------------- |\n| plots      | Array  | array of x y coords [ { x, y }, ...]             |\n| type       | string | [Canvas Methods documentation](../canvas_mehtods) |\n| opts       | object | [Canvas Methods documentation](../canvas_mehtods) |\n\n#### Minimal Custom Indicator Definition\n\n```javascript\n// custom-indicator.js\n// proof of concept for user defined indicators\n\n// importing talibAPI is only required if you intend to use the talib functions provided by the chart to calculate your indicator\nimport { Indicator, Range, talibAPI, uid } from \"tradex-chart\"\n\nexport default class Test extends Indicator {\n\n  name = \"Test Custom Inicator\"\n  shortName = \"Test\"\n\n  timePeriod = 20\n\n  #defaultStyle = {\n    stroke: \"#0088cc\",\n    width: \"1\",\n    dash: undefined,\n  }\n\n  style = {}\n\n  static inCnt = 0\n  static primaryPane = true\n  // static scale is required for off chart indicators\n  // static scale = YAXIS_TYPES[0] // YAXIS_TYPES - default\n  static colours = []\n\n\n  /**\n   * Creates an instance of Test.\n   * @param {Object} target - canvas scene\n   * @param {Object} xAxis - timeline axis instance\n   * @param {Object} yAxis - scale axis instance\n   * @param {Object} config - theme / styling\n   * @param {Object} parent - chart pane instance that hosts the indicator\n   * @param {Object} params - contains minimum of overlay instance\n   * @memberof Test\n   */\n  constructor(target, xAxis=false, yAxis=false, config, parent, params) {\n    super(target, xAxis, yAxis, config, parent, params)\n\n    const overlay = params.overlay\n    // initialize indicator values\n    this.id = params.overlay?.id || uid(this.shortName)\n    // merge user defined settings (if any) with defaults\n    this.style = (overlay?.settings?.style) \n      ? { ...this.#defaultStyle, ...overlay.settings.style } \n      : { ...this.#defaultStyle, ...config.style }\n    // calculate back history if missing\n    this.calcIndicatorHistory()\n    // enable processing of price stream\n    this.setUpdateValue = (value) => { \n      this.updateValue(value) \n    }\n    // add the indicator legend to the chart pane\n    this.addLegend()\n    // set the local range max min Y-Axis values if required\n    // this.chart.setLocalRange(0, 150)\n  }\n\n  /**\n   * define where indicator should be displayed\n   * valid returned values can be: true, false (boolean), both (string)\n   * @readonly\n   */\n  get primaryPane() { return Test.primaryPane }\n  get defaultStyle() { return this.#defaultStyle }\n\n\n  /**\n   * return inputs required to display indicator legend on chart pane\n   * legends can display multiple values\n   * @param {Array} [pos=this.chart.cursorPos] - optional\n   * @returns {Object} - {inputs, colours, labels}\n   */\n  legendInputs(pos=this.chart.cursorPos) {\n    if (this.overlay.data.length == 0) return false\n\n    // determine which legend labels to display\n    let labels = [false]\n    // c - retrieve data index\n    let {c, colours} = super.legendInputs(pos)\n    // build an object of input keys (labels) and values\n    let inputs = {x: this.scale.nicePrice(this.overlay.data[c][1])}\n\n    /**\n      @param {Object} inputs - property names are used as labels\n      @param {Array} colours - array of #rrggbb(aa) values\n      @param {Array} labels - array of which input labels to dispaly [true, false, ...]\n    */\n    return {inputs, colours, labels}\n  }\n\n  /**\n   * process new candle stream value\n   * @param {Array} candle - [timestamp, open, high, low, close, volume]\n   * @memberof Test\n   */\n  updateValue(candle) {\n    this.value = candle\n  }\n\n  calcIndicator(range=this.range) {\n    let start, end;\n    // number of values to use in indicator calculation\n    let p = this.timePeriod\n\n    // is it a Range instance?\n    if(range instanceof Range) {\n      // if not calculate entire history\n      start = 0\n      end = range.dataLength - p + 1\n    }\n    else if ( \"indexStart\" in range || \"indexEnd\" in range ||\n              \"tsStart\" in range ||  \"tsEnd\" in range ) {\n      start = range.indexStart || this.Timeline.t2Index(range.tsStart || 0) || 0\n      end = range.indexEnd || this.Timeline.t2Index(range.tsEnd) || this.range.Length - 1\n      end - p\n    }\n    else return false\n\n    // if not enough data for calculation fail\n    if ( end - start < p ) return false\n\n    let data = [];\n    let i, v, entry;\n\n    while (start < end) {\n      // fetch the data required to calculate the indicator\n      input = this.indicatorInput(start, start + p)\n \n      // do your indicator calculation\n      v = doSomething(input)\n\n      data.push([this.range.value(start + p - 1)[0], v])\n      start++\n    }\n    return data\n  }\n\n  calcIndicatorHistory() {\n    // if overlay history is missing, calculate it\n    if (this.overlay.data.length < this.timePeriod) {\n      const data = this.calcIndicator()\n      if (data) this.overlay.data = data\n    }\n  }\n  \n  /**\n   * draw the indicator\n   * @param {Object} range - current displayed range of candles\n   */\n  draw(range=this.range) {\n    // minimum of two candles are required for this indicator\n    if (this.overlay.data.length < 2 ) return false\n    // clear the indicator overlay (chart layer)\n    this.scene.clear()\n\n    // draw your indicator...\n\n    // array to hold sequence points to draw\n    const plots = []\n    // indicator data\n    const data = this.overlay.data\n    // current candle width, chart zoom modifies this\n    const width = this.xAxis.candleW\n    // basic plot entry\n    const plot = {\n      w: width,\n    }\n    // first timestamp in current range\n    let t = range.value(range.indexStart)[0]\n    let s = this.overlay.data[0][0]\n    let c = (t - s) / range.interval\n    let o = this.Timeline.rangeScrollOffset;\n    let i = range.Length + o + 2\n    let style = {}\n\n    while(i) {\n      if (c < 0 || c >= this.overlay.data.length) {\n        plots.push({x: null, y: null})\n      }\n      else {\n        plot.x = this.xAxis.xPos(data[c][0])\n        plot.y = this.yAxis.yPos(data[c][1])\n        plots.push({...plot})\n      }\n      c++\n      i--\n    }\n    // process the plots\n    this.plot(plots, \"renderLine\", this.style)\n    // render the indicator\n    this.target.viewport.render();\n  }\n}\n```\n\n## Settings\n\nCurrent indicator settings can be retrieved with the following call:\n\n```javascript\nchart0.getIndicator(\"TX_lj7216mu_vq6_0-Chart_0-EMA_1\").settings()\n```\n\nIndicator settings can also modified with the same call by passing an object:\n\n```javascript\nconst newSettings = {}\nchart0.getIndicator(\"TX_lj7216mu_vq6_0-Chart_0-EMA_1\").settings(newSettings)\n```\n\n### Invokeing the Settings Dialogue\n\nThe indicator Settings Dialogue can be invoked with the following:\n\n```javascript\nchart0.getIndicator(\"TX_lj7216mu_vq6_0-Chart_0-EMA_1\").invokeSettings()\n```\n\nInvocation of the Settings Dialogue can be modified or replaced with a user defined function, either by passing an object to the method:\n\n```javascript\nconst callback = {\n    indicatorSettings: {fn: (c)=>{ alert(c.id) }, own: true}\n  }\nchart0.getIndicator(\"TX_lj7216mu_vq6_0-Chart_0-EMA_1\").invokeSettings(callback)\n```\n\nSetting ``own: true`` will cause the default dialogue not to be invoked.\n\nAlternatively, if in the initial chart configuration, the ``config.callbacks.indicatorSettings`` is given a callback object, this will make the change permanent.\n\n## How the Indicator Updates\n\nInitial data is passed to the indicator via the [Chart State](../state). It can also be [added later (updated)](../state#merging-data-into-the-state) via the API which handles the Chart State.\n[Streaming data (OHLCV)](../streaming_price_data) can also be fed to the custom indicator.\nIf you take a look at the example in the repo ``./custom-indicator.js``  you will see the following methods:\n\n* ``updateValue()`` - accepts the streaming data ``{Array.<number>} candle - [timestamp, open, high, low, close, volume]``\n* ``calcIndicator()`` - accepts the Range ``range=this.range``\n* ``legendInputs()`` - accepts cursor pos on chart which is automatically passed to it by the chart\n* ``draw()`` - accepts the Range ``range=this.range``\n\nThese are the four main methods of your custom indicator, which extends the default indicator class.\n\nIf you examine the demo test page ./index.js and examine the function ``kline_Binance()`` you will see that the data stream is passed to the chart via ``mergeData()``. The chart distributes this value to all indicators active on the chart via their ``updateValue()`` method, which is why this method is required for your own custom indicator.\n\nAny`` mergeData()`` call, whether for a block of back history or a single streaming candle, will automatically invoke each indicator's ``calcIndicator()``, which is why it is also a requirement for your own custom indicators.\n\n``draw()`` is also automatically invoked on all indicators, including custom indicators if there is any chart event that triggers the chart to update and redraw. This too must be provided by your custom indicator. \n\n## Indicator Calculation\n\nOf course the [functions provided by the TA-Lib](indicators_talib) can be leveraged for custom indicators via the chart API. The chart will take care of initializing the TA-Lib wasm component and return a promise.\n\nFirstly your indicator needs to import the ``talibAPI`` that the chart exports. Doing so provides you with all of the talib function definitions which tell you what inputs the function requires and what output it will return.\n\n```javascript\nimport { talibAPI } from \"../definitions/talib-api\";\n```\nYou can also import only the required definitions for the functions you want to work with.\n\n```javascript\nimport { AROON } from \"../definitions/talib-api\";\n```\n\nAll indicators relying upon TA-Lib functions should defer any data processing until the promise is fulfilled.\n\n```javascript\n      if (this.core.TALibReady) calc()\n      else  this.core.talibAwait.push(calc.bind(this))\n```";
						const data = {title:"Custom Indicators",description:"Defining, registering and working with custom indicators",editUrl:true,head:[],template:"doc"};
						const _internal = {
							type: 'content',
							filePath: "/mnt/ext4/Home/neoarttec/Archives/Linux/Crypto/Trading/Mercury/MercuryTrader/component-module-tests/TradeX/tradex-chart/src/docs/src/content/docs/reference/indicators_custom.md",
							rawData: "\ntitle: Custom Indicators\ndescription: Defining, registering and working with custom indicators",
						};

export { _internal, body, collection, data, id, slug };
