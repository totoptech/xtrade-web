<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// core.js
// it all begins here...

// import * as talib from "talib-web"
import { isArray, isBoolean, isFunction, isNumber, isObject, isString } from './utils/typeChecks'
import DOM from './utils/DOM'
import * as Time from './utils/time'
import { limit } from './utils/number'
import { interval2MS, isTimeFrame, SECOND_MS } from "./utils/time"
import { copyDeep } from './utils/utilities'
import State from './state'
import { Range, calcTimeIndex } from "./model/range"
import StateMachine from './scaleX/stateMachne'
import Stream from './helpers/stream'
import Theme from "./helpers/theme"
import WebWorker from "./helpers/webWorkers"
import Indicators from './definitions/indicators'
import style, { CHART_MINH, CHART_MINW, cssVars, TOOLSW } from './definitions/style'
import Tradex_chart from "./components/views/tradeXchart"
import UtilsBar from './components/utils'
import ToolsBar from './components/tools'
import MainPane from './components/main'
import WidgetsG from './components/widgets'

import {
  NAME,
  ID,
  RANGELIMIT,
  PRICE_PRECISION,
  VOLUME_PRECISION,
  STREAM_LISTENING,
  STREAM_NEWVALUE,
  STREAM_UPDATE
} from './definitions/core'

import { LIMITFUTURE, MINCANDLES, YAXIS_BOUNDS } from "./definitions/chart"

import { GlobalStyle } from './definitions/style'
import { precision } from "./utils/number"

/**
 * The root class for the entire chart
 * @export
 * @class TradeXchart
 */
export default class TradeXchart extends Tradex_chart {

  static #cnt = 0
  static #cfg = {}
  static #instances = {}
  static #talibReady = false
  static get talibReady() { return TradeXchart.#talibReady }
  static initErrMsg = `${NAME} requires "talib-web" to function properly. Without it, some features maybe missing or broken.`
  static permittedClassNames = 
  ["TradeXchart","Chart","MainPane","OffChart","OnChart",
  "ScaleBar","Timeline","ToolsBar","UtilsBar","Widgets"]

  #id
  #name = NAME
  #shortName = NAME
  #el = undefined
  #mediator
  #core
  #config
  #options
  #elements = {}
  #elTXChart
  #elUtils
  #elBody
  #elTools
  #elMain
  #elRows
  #elTime
  #elYAxis
  #elWidgetsG

  #inCnt = null
  #modID
  #hub = {}
  #state = {}
  #userClasses = []
  #chartIsEmpty = true
  #data
  #range
  #rangeStartTS
  #rangeLimit = RANGELIMIT
  #indicators = Indicators
  #TALib
  #theme
  #themeTemp

  chartWMin = CHART_MINW
  chartHMin = CHART_MINH
  chartW_Reactive = true
  chartH_Reactive = true
  chartBGColour = GlobalStyle.COLOUR_BG
  chartTxtColour = GlobalStyle.COLOUR_TXT
  chartBorderColour = GlobalStyle.COLOUR_BORDER

  utilsH = 35
  toolsW = 40
  timeH  = 50
  scaleW = 60

  #UtilsBar
  #ToolsBar
  #MainPane = {
    chart: {},
    time: {}
  }
  #WidgetsG

  panes = {
    utils: this.#UtilsBar,
    tools: this.#ToolsBar,
    main: this.#MainPane,
  }

  #time = {
    rangeTotal: true,
    range: {},
    total: {},
    timeFrameMS: 0,
    timeFrame: '',
    timeZone: '',
    indexed: false
  }

  // console outputs
  logs = false
  infos = false
  warnings = false
  errors = false
  timer = false
  
  #mousePos = {x:0, y:0}
  #scrollPos = 0
  #smoothScrollOffset = 0
  #panBeginPos = [null, null, null, null]

  #workers
  #stream
  #candles
  #pricePrecision
  #volumePrecision

  #delayedSetRange = false

  #renderer = {
    status: "idle",
    buffer: {
      n: true,
      "1": {},
      "2": {}
    },
    curr: {
      frame: null,
      priority: 0
    },
    cache: []
  }

  /**
   * Create a new TradeXchart instance
   *
   * @static
   * @param {DOM_element} container - HTML element to mount the chart on
   * @param {object} [config={}] - chart config
   * @param {object} state - chart state
   * @return {instance}  
   * @memberof TradeXchart
   */
    static create(config={}) {

      // global init for all TradeX charts
      if (TradeXchart.#cnt == 0) {
        TradeXchart.#cfg.CPUCores = navigator.hardwareConcurrency
        TradeXchart.#cfg.api = {
          permittedClassNames:TradeXchart.permittedClassNames,
        }
      }

      if (!TradeXchart.#talibReady) {
        (async () => {
          try {
            if ((typeof config.talib !== "object") || 
                // (config.talib[Symbol.toStringTag] !== "Module") ||
                (typeof config.talib.init !== "function"))
                  throw new Error(`${TradeXchart.initErrMsg}`)
            await config.talib.init("node_modules/talib-web/lib/talib.wasm");
            TradeXchart.#talibReady = true
          } catch (e) {
            throw new Error(`${TradeXchart.initErrMsg} ${e.message}`)
          }
        })();
      }
      return TradeXchart.#cfg
    }
  
    /**
     * Destroy a chart instance, clean up and remove data
     * @static
     * @param {instance} chart 
     * @memberof TradeXchart
     */
    static destroy(chart) {
      if (chart.constructor.name === "TradeXchart") {
        chart.end()
        const inCnt = chart.inCnt;
        delete TradeXchart.#instances[inCnt];
      }
    }
  
    static cnt() {
      return TradeXchart.#cnt++
    }

  /**
   * Creates an instance of TradeXchart.
   * @param {instance} mediator - module api
   * @param {object}[config={}] - chart configuration
   * @memberof TradeXchart
   */
  constructor () {
    super()
    this.#inCnt = TradeXchart.cnt()
    this.#id = `${ID}_${this.#inCnt}`

    console.warn(`!WARNING!: ${NAME} breaking changes since V 0.101.7`)
    console.log("TXC:",this.inCnt)

    this.oncontextmenu = window.oncontextmenu
    this.#workers = WebWorker
  }

  log(l) { if (this.logs) console.log(l) }
  info(i) { if (this.infos) console.info(i) }
  warning(w) { if (this.warnings) console.warn(w) }
  error(e) { if (this.errors) console.error(e) }
  time(n) { if (this.timer) console.time(n) }
  timeLog(n) { if (this.timer) console.timeLog(n) }
  timeEnd(n) { if (this.timer) console.timeEnd(n) }

  set id(id) { this.#id = id }
  get id() { return this.#id }
  get name() { return this.#name }
  get shortName() { return this.#shortName }
  get mediator() { return this.#mediator }
  get options() { return this.#options }
  get config() { return this.#config }
  get core() { return this.#core }
  get inCnt() { return this.#inCnt }

  set elUtils(el) { this.#elUtils = el }
  get elUtils() { return this.#elUtils }
  set elTools(el) { this.#elTools = el }
  get elTools() { return this.#elTools }
  set elBody(el) { this.#elBody = el }
  get elBody() { return this.#elBody }
  set elMain(el) { this.#elMain = el }
  get elMain() { return this.#elMain }
  set elTime(el) { this.#elTime = el }
  get elTime() { return this.#elTime }
  set elYAxis(el) { this.#elYAxis = el }
  get elYAxis() { return this.#elYAxis }
  set elWidgetsG(el) { this.#elWidgetsG = el }
  get elWidgetsG() { return this.#elWidgetsG }

  get UtilsBar() { return this.#UtilsBar }
  get ToolsBar() { return this.#ToolsBar }
  get MainPane() { return this.#MainPane }
  get Timeline() { return this.#MainPane.time }
  get WidgetsG() { return this.#WidgetsG }
  get Chart() { return this.#MainPane.chart }

  get state() { return this.#state }
  get chartData() { return this.#state.data.chart.data }
  get offChart() { return this.#state.data.offchart }
  get onChart() { return this.#state.data.onchart }
  get datasets() { return this.#state.data.datasets }
  get allData() {
    return {
      data: this.chartData,
      onChart: this.onChart,
      offChart: this.offChart,
      datasets: this.datasets
    }
  }
  get rangeLimit() { return (isNumber(this.#rangeLimit)) ? this.#rangeLimit : RANGELIMIT }
  get range() { return this.#range }
  get time() { return this.#time }
  get TimeUtils() { return Time }

  get theme() { return this.#theme.getCurrent() }
  get settings() { return this.#state.data.chart.settings }
  get indicators() { return this.#indicators }
  get TALib() { return this.#TALib }
  get TALibReady() { return TradeXchart.talibReady }
  get hub() { return this.#hub }

  get candleW() { return this.Timeline.candleW }
  get candlesOnLayer() { return this.Timeline.candlesOnLayer }
  get buffer() { return this.MainPane.buffer }
  get bufferPx() { return this.MainPane.bufferPx }
  set scrollPos(pos) { this.setScrollPos(pos) }
  get scrollPos() { return this.#scrollPos }
  get smoothScrollOffset() { return 0 } //{ return this.#smoothScrollOffset }
  get rangeScrollOffset() { return Math.floor(this.bufferPx / this.candleW) }
  get mousePos() { return this.#mousePos }

  get pricePrecision() { return this.#pricePrecision }
  get volumePrecision() { return this.#volumePrecision }

  set stream(stream) { return this.setStream(stream) }
  get stream() { return this.#stream }
  get worker() { return this.#workers }
  get isEmpty() { return this.#chartIsEmpty }
  set candles(c) { if (isObject(c)) this.#candles = c }
  get candles() { return this.#candles }

  /**
   * Target element has been validated as a mount point, 
   * let's start building
   * @param {object} config - chart configuration
   */
  start(config) {
    config = {...TradeXchart.create(config), ...config}
    this.logs = (config?.logs) ? config.logs : false
    this.infos = (config?.infos) ? config.infos : false
    this.warnings = (config?.warnings) ? config.warnings : false
    this.errors = (config?.errors) ? config.errors : false
    this.timer = (config?.timer) ? config.timer : false

    this.#config = config
    this.#inCnt = config.cnt || this.#inCnt
    this.#modID = config.modID
    this.#TALib = config.talib
    this.#el = this
    this.#core = this

    let state = copyDeep(config?.state)
    let deepValidate = config?.deepValidate || false
    let isCrypto = config?.isCrypto || false
    this.#state = State.create(state, deepValidate, isCrypto)
    delete config.state
    this.log(`Chart ${this.#id} created with a ${this.#state.status} state`)

    // time frame
    let tf = "1s"
    let ms = SECOND_MS
    if (!isObject(config?.stream) &amp;&amp; this.#state.data.chart.data.length &lt; 2) {
      this.warning(`${NAME} has no chart data or streaming provided.`)
      // has a time frame been provided?
      ;({tf, ms} = isTimeFrame(config?.timeFrame))
      this.#time.timeFrame = tf
      this.#time.timeFrameMS = ms
      this.#chartIsEmpty = true
    }
    // is the chart streaming with an empty chart?
    else if (isObject(config?.stream) &amp;&amp; this.#state.data.chart.data.length &lt; 2) {
      // has a time frame been provided?
      ;({tf, ms} = isTimeFrame(config?.timeFrame))
      console.log("tf:",tf,"ms:",ms)

      this.#time.timeFrame = tf
      this.#time.timeFrameMS = ms
      this.#chartIsEmpty = true
      this.#delayedSetRange = true
    }
    // chart has back history and optionally streaming
    else {
      this.#time.timeFrame = this.#state.data.chart.tf 
      this.#time.timeFrameMS = this.#state.data.chart.tfms
      this.#chartIsEmpty = false
    }

    const id = (isObject(config) &amp;&amp; isString(config.id)) ? config.id : null
    this.setID(id)
    this.classList.add(this.id)

    // process config
    if (isObject(config)) {
      for (const option in config) {
        if (option in this.props()) {
          this.props()[option](config[option])
        }
      }
    }

    // set default range
    this.getRange(null, null, {interval: this.#time.timeFrameMS, core: this})

    if (this.#range.Length > 1) {
      // now set user defined (if any) range
      const rangeStart = calcTimeIndex(this.#time, this.#rangeStartTS)
      const end = (rangeStart) ? 
        rangeStart + this.#rangeLimit :
        this.chartData.length - 1
      const start = (rangeStart) ? rangeStart : end - this.#rangeLimit
      this.#rangeLimit = end - start
      this.setRange(start, end)
    }

    this.insertAdjacentHTML('beforebegin', `&lt;style title="${this.id}_style">&lt;/style>`)

    this.#WidgetsG = new WidgetsG(this, {widgets: config?.widgets})
    this.#UtilsBar = new UtilsBar(this, config)
    this.#ToolsBar = new ToolsBar(this, config)
    this.#MainPane = new MainPane(this, config)

    this.setTheme(this.#themeTemp.ID)

    this.log(`${this.#name} instantiated`)
    this.log("...processing state")

    this.#scrollPos = this.bufferPx * -1

    this.eventsListen()

    this.UtilsBar.start()
    this.ToolsBar.start()
    this.MainPane.start()
    this.WidgetsG.start()

    this.stream = this.#config.stream

    if (this.#delayedSetRange) 
      this.on(STREAM_UPDATE, this.delayedSetRange.bind(this))

    this.refresh()
  }

  /**
   * Stop all chart event processing and remove the chart from DOM.
   * In other words, destroy the chart.
   * @memberof TradeXchart
   */
  end() {
    this.log("...cleanup the mess")
    this.removeEventListener('mousemove', this.onMouseMove)

    this.off(STREAM_UPDATE, this.onStreamUpdate)

    this.UtilsBar.end()
    this.ToolsBar.end()
    this.MainPane.end()
    this.WidgetsG.end()

    this.#workers.end()
    this.#state = null

    // DOM.findByID(this.id).remove
  }

  eventsListen() {
    this.addEventListener('mousemove', this.onMouseMove.bind(this))

    this.on(STREAM_UPDATE, this.onStreamUpdate.bind(this))
  }

  /** Subscribe to a topic
  *
  * @param {String} topic      - The topic name
  * @param {Function} callback - The function that is called if another module
  *                              publishes to the specified topic
  * @param {Object}  context   - The context the function(s) belongs to
  */
   on(topic, handler, context) {
    if (!isString(topic) || !isFunction(handler)) return
    if (!this.#hub[topic]) this.#hub[topic] = [];
    this.#hub[topic].push({handler, context});
  }

  /** Unsubscribe from a topic
  *
  * @param {String} topic - The topic name
  * @param {Function} cb  - The function that is called if an other module
  *                         publishes to the specified topic
  */
  off(topic, handler) {
    if (!isString(topic)) return

    const i = (this.#hub[topic] || []).findIndex(h => h === handler);
    if (i > -1) this.#hub[topic].splice(i, 1);
    if (this.#hub[topic].length === 0) delete this.#hub[topic];
  }

  /** Publish an topic
  *
  * @param {String} topic - The topic name
  * @param {Object}  data - The data to publish
  */
  emit(topic, data) {
    if (!isString(topic)) return
    (this.#hub[topic] || []).forEach(cb => cb.handler.call(cb.context, data));
  }

  /** Execute a task
  *
  * @param {String} topic - The topic name
  * @param {Object} data    - The data that gets published
  * @param {Function} cb    - callback method
  */
  execute(channel, data, cb) {

  }

  onMouseMove(e) {
    this.#mousePos.x = e.clientX
    this.#mousePos.y = e.clientY
  }

  onStreamUpdate(candle) {
    const r = this.range
    // is candle visible?
    if (r.inRange(candle[0])) {
      const max = r.valueMax // * (1 - YAXIS_BOUNDS)
      const min = r.valueMin // * (1 + YAXIS_BOUNDS)
      // is candle testing display boundaries?
      if (candle[2] > max || candle[3] &lt; min) {
        // recalculate range
        // TODO: instead of recalculate, update Range
        this.setRange(r.indexStart, r.indexEnd)

        this.emit("chart_yAxisRedraw", this.range)
      }
    }
  }

  props() {
    return {
      // id: (id) => this.setID(id),
      userClasses: (classes) => this.setUserClasses(classes),
      width: (width) => this.setWidth(width),
      height: (height) => this.setHeight(height),
      widthMin: (width) => this.setWidthMin(width),
      heightMin: (height) => this.setHeightMin(height),
      widthMax: (width) => this.setWidthMax(width),
      heightMax: (height) => this.setHeightMax(height),
      logs: (logs) => this.logs = (isBoolean(logs)) ? logs : false,
      infos: (infos) => this.infos = (isBoolean(infos)) ? infos : false,
      warnings: (warnings) => this.warnings = (isBoolean(warnings)) ? warnings : false,
      errors: (errors) => this.errors = (isBoolean(errors)) ? errors : false,
      rangeStartTS: (rangeStartTS) => this.#rangeStartTS = (isNumber(rangeStartTS)) ? rangeStartTS : undefined,
      rangeLimit: (rangeLimit) => this.#rangeLimit = (isNumber(rangeLimit)) ? rangeLimit : RANGELIMIT,
      indicators: (indicators) => this.#indicators = {...Indicators, ...indicators },
      theme: (theme) => { this.#themeTemp = this.addTheme(theme) },
      stream: (stream) => this.#stream = (isObject(stream)) ? stream : {},
      pricePrecision: (precision) => this.setPricePrecision(precision),
      volumePrecision: (precision) => this.setVolumePrecision(precision),
    }
  }

  getInCnt() { return this.#inCnt }

  setID(id) {
    if (isString(id)) 
      this.#id = id + this.#inCnt
    else 
      this.#id = ID + this.#inCnt
  }
  getID() { return this.#id }

  getModID() { return this.#modID }


  /**
   * Set chart width and height
   * @param {number} w - width in pixels
   * @param {number} h - height in pixels
   * @memberof TradeXchart
   */
  setDimensions(w, h) {
    const dims = super.setDimensions(w, h) 

    this.emit("global_resize", dims)
  }

  setUtilsH(h) {
    this.utilsH = h
    this.#elUtils.style.height = `${h}px`
  }

  setToolsW(w) {
    this.toolsW = w
    this.#elTools.style.width = `${w}px`
  }

  setNotEmpty() {
    this.#chartIsEmpty = false
  }

  /**
   * Set the price accuracy
   * @param {number} pricePrecision - Price accuracy
   * @memberof TradeXchart
   */
    setPricePrecision (pricePrecision) {
    if (!isNumber(pricePrecision) || pricePrecision &lt; 0) {
      pricePrecision = PRICE_PRECISION
    }
    this.#pricePrecision = pricePrecision
  }

  /**
   * Set the volume accuracy
   * @param {number} volumePrecision - Volume accuracy
   * @memberof TradeXchart
   */
  setVolumePrecision (volumePrecision) {
    if (!isNumber(volumePrecision) || volumePrecision &lt; 0) {
      volumePrecision = VOLUME_PRECISION
    }
    this.#volumePrecision = volumePrecision
  }

  /**
   * Add a theme to the chart,
   * if no current theme is set, make this the current one.
   * @param {object} theme - Volume accuracy
   * @memberof TradeXchart
   */
  addTheme(theme) {
    this.#theme = Theme.create(theme, this)
    return this.#theme
  }

  /**
 * Set the chart theme
 * @param {object} theme - Volume accuracy
 * @memberof TradeXchart
 */
  setTheme(ID) {
    this.#theme.current = ID
    const current = this.#theme
    const style = document.querySelector(`style[title=${this.id}_style]`)
    const borderColour = `var(--txc-border-color, ${current.chart.BorderColour}`

    let innerHTML = `.${this.id} { `

    // modify core style sheet custom CSS variables
    innerHTML +=`--txc-background: ${current.chart.Background}; `

    // Chart component
    this.style.background = `var(--txc-background, ${current.chart.Background})`
    this.style.border = `${current.chart.BorderThickness}px solid`
    this.style.borderColor = borderColour

    // Main Pane
    innerHTML +=`--txc-border-color:  ${current.chart.BorderColour}; `
    this.#elMain.rows.style.borderColor = borderColour

    // Timeline
    innerHTML += `--txc-time-scrollbar-color: ${current.chart.BorderColour}; `
    innerHTML += `--txc-time-handle-color: ${current.xAxis.handle}; `
    innerHTML += `--txc-time-slider-color: ${current.xAxis.slider}; `
    innerHTML += `--txc-time-cursor-fore: ${current.xAxis.colourCursor}; `
    innerHTML += `--txc-time-cursor-back: ${current.xAxis.colourCursorBG}; `
    innerHTML += `--txc-time-icon-color: ${current.icon.colour}; `
    innerHTML += `--txc-time-icon-hover-color: ${current.icon.hover}; `

    this.#elTime.overview.scrollBar.style.borderColor = borderColour;
    this.#elTime.overview.handle.style.backgroundColor = `var(--txc-time-handle-color, ${current.xAxis.handle})`;

    this.#elTime.overview.style.setProperty("--txc-time-slider-color", current.xAxis.slider);
    this.#elTime.overview.style.setProperty("--txc-time-icon-color", current.icon.colour);
    this.#elTime.overview.style.setProperty("--txc-time-icon-hover-color", current.icon.hover);

    // Legends
    for (let [key, legend] of Object.entries(this.Chart.legend.list)) {
      legend.el.style.color = `var(--txc-legend-color, ${current.legend.colour})`
      legend.el.style.font = `var(--txc-legend-font, ${current.legend.font})`
      // TODO: control icons
    }

    // Utils
    for (let t of this.#elUtils.icons) {
      if (t.className != "icon-wrapper") continue

      t.children[0].style.fill = current.icon.colour
    }

    // Tools
    for (let t of this.#elTools.icons) {
      if (t.className != "icon-wrapper") continue

      t.children[0].style.fill = current.icon.colour
    }

    innerHTML += ` }`
    style.innerHTML = innerHTML
  }

  setScrollPos(pos) {
    pos = Math.round(pos)
    if (isNumber(pos) &amp;&amp; pos &lt;= 0 &amp;&amp; pos >= this.bufferPx * -1) this.#scrollPos = pos
    else {
      this.emit("Error", `setScrollPos: not a valid value`)
    }
  }

  setUserClasses(c) {
    if (isString(c)) {
      let uc = c.split(" ")
      this.#userClasses = uc
    }
    else if (isArray(c)) {
      this.#userClasses = c
    }
    else {
      this.warn(`Supplied user classes not valid. Expecting type String or Array`)
    }

    for (let cl of this.#userClasses) {
      classes.add(cl)
    }
  }

  /**
   * specify a chart stream
   * @memberof TradeXchart
   * @param {object} stream 
   * @returns {instance}
   */
  setStream(stream) {
    if (this.stream?.constructor.name == "Stream") {
      this.error("Error: Invoke stopStream() before starting a new one.")
      return false
    }
    else if (isObject(stream)) {
      if (this.allData.data.length == 0 &amp;&amp; isString(stream.timeFrame)) {
        ;({tf, ms} = isTimeFrame(stream?.timeFrame))
        this.#time.timeFrame = tf
        this.#time.timeFrameMS = ms
      }
      this.#stream = new Stream(this)
      return this.#stream
    }
  }

  stopStream() {
    if (this.stream.constructor.name == "Stream") {
      this.stream.stop()
    }
  }

  delayedSetRange() {
    while (this.#delayedSetRange) {
      let r = this.range
      let l = Math.floor((r.indexEnd - r.indexStart) / 2)
      this.setRange(l * -1, l)
      this.off(STREAM_UPDATE, this.delayedSetRange)
      this.#delayedSetRange = false
      this.refresh()
    }
  }
  
  /**
   * Calculate new range index / position from position difference
   * typically mouse drag or cursor keys
   * @param {array} pos - [x2, y2, x1, y1, xdelta, ydelta]
   */
  updateRange(pos) {

    if (!isArray(pos) || !isNumber(pos[4]) || pos[4] == 0) return

    let dist, offset, scrollPos, r;

    dist = pos[4]
    scrollPos = this.#scrollPos + dist
    r = scrollPos % this.candleW

    if (scrollPos &lt; this.bufferPx * -1) {
      scrollPos = 0
      this.offsetRange(this.rangeScrollOffset * -1)
    }
    else if (scrollPos > 0) {
      scrollPos = this.bufferPx * -1
      this.offsetRange(this.rangeScrollOffset)
    }

    this.#scrollPos = scrollPos
    this.emit("scrollUpdate", scrollPos)

    // console.log(`Main W: ${this.#MainPane.width}, Candle W: ${this.candleW}, r: ${this.#MainPane.width % this.candleW}`)
    // console.log(`dist: ${dist}, bufferPx: ${this.bufferPx}, offset: ${offset}, scrollPos: ${scrollPos} \n`)
  }


  xupdateRange(pos) {

    if (pos[4] == 0) return
    
    let dist, offset, scrollPos, r;
    dist = pos[4]
    scrollPos = this.#scrollPos + dist
    r = scrollPos % this.candleW
    offset = (scrollPos - r) / this.candleW

    // if (dist > 0) offset = offset * -1
    offset = (dist > 0) ? offset : offset * -1
    this.offsetRange(offset)
    this.scrollPos = r

    this.#scrollPos = r
    this.emit("scrollUpdate", scrollPos)

    // console.log(`Main W: ${this.#MainPane.width}, Candle W: ${this.candleW}, r: ${this.#MainPane.width % this.candleW}`)
    // console.log(`dist: ${dist}, bufferPx: ${this.bufferPx}, offset: ${offset}, scrollPos: ${scrollPos} \n`)
  }


  offsetRange(offset) {
    let start = this.range.indexStart - offset,
        end = this.range.indexEnd - offset;

    this.setRange(start, end)
  }

  /**
   * initialize range
   * @param {number} start - index
   * @param {number} end - index
   * @memberof TradeXchart
   */
  getRange(start=0, end=0, config={}) {
    this.#range = new Range(this.allData, start, end, config)
    this.#range.interval = this.#time.timeFrameMS
    this.#range.intervalStr = this.#time.timeFrame
    this.#time.range = this.#range
  }

  /**
   * set start and end of range
   * @param {number} start - index
   * @param {number} end - index
   * @memberof TradeXchart
   */
  setRange(start=0, end=this.rangeLimit) {
    const max = (this.config?.maxCandles)? this.config.maxCandles : 
      (this.Chart?.layerWidth) ? this.Chart.layerWidth : this.Chart.width
    this.#range.set(start, end, max)
  }

  jumpToIndex(start, nearest=true, centre=true) {
    let length = this.range.Length
    let end = start + length

    if (nearest) start = limit(start, 0, this.range.dataLength)
    if (centre) {
      start -= length / 2
      end -= length / 2
    }
    this.setRange(start, end)
  }

  jumpToTS(ts, nearest=true, centre=true) {
    let start = this.Timeline.xAxis.t2Index(ts)
    this.jumpToIndex(start, nearest=true, centre=true)
  }

  jumpToStart(nearest=true, centre=true) {
    this.jumpToIndex(0, nearest=true, centre=true)
  }

  jumpToEnd(nearest=true, centre=true) {
    let end = this.range.dataLength - this.range.Length

    if (centre) end += this.range.Length / 2

    this.jumpToIndex(end, nearest=true, centre=false)
  }

  /**
   * Merge a block of data into the chart state.
   * Used for populating a chart with back history.
   * Merge data must be formatted to a Chart State.
   * Optionally set a new range upon merge.
   * @param {object} merge - merge data must be formatted to a Chart State
   * @param {boolean|object} newRange - false | {start: number, end: number}
   * @memberof TradeXchart
   */
  // TODO: merge indicator data?
  // TODO: merge dataset?
  mergeData(merge, newRange=false) {
    if (!isObject(merge)) return false

    let i, j, p=0, start, end;
    const data = this.allData.data
    const mData = merge?.data
    const inc = (this.range.inRange(mData[0][0])) ? 1 : 0

    if (isArray(mData) &amp;&amp; mData.length > 0) {
      i = mData.length - 1
      j = data.length - 1

      if (data.length == 0) this.allData.data.push(...mData)
      else {
        const r1 = [data[0][0], data[j][0]]
        const r2 = [mData[0][0], mData[i][0]]
        const o = [Math.max(r1[0], r2[0]), Math.min(r1[1], r2[1])]

        // overlap between existing data and merge data
        if (o[1] >= o[0]) {
// TODO: merge with overlap
        }
        // no overlap, insert the new data
        else {
          this.allData.data.push(...mData)
        }
      }
    }

    if (newRange) {
      if (isObject(newRange)) {
        start = (isNumber(newRange.start)) ? newRange.start : this.range.indexStart
        end = (isNumber(newRange.end)) ? newRange.end : this.range.indexEnd
      }
      else {
        if (mData[0][0] )
        start = this.range.indexStart + inc
        end = this.range.indexEnd + inc
      }
      this.setRange(start, end)
    }

  }

  /**
   * Resize the chart
   * @memberof TradeXchart
   * @param {number} width - pixels
   * @param {number} height - pixels
   * @returns {boolean} - success or failure
   */
  resize(width, height) {
    if (!isNumber(width) &amp;&amp; !isNumber(height)) return false

    this.setDimensions(width, height)
    return true
  }

  /**
   * refresh / redraw the chart
   * @memberof TradeXchart
   */
  refresh() {
    this.MainPane.draw()
    this.Chart.refresh()
    const offCharts = this.MainPane.offCharts
    offCharts.forEach((offChart, key) => {
      offChart.refresh()
    })
    // TODO: drawing tools
  }

  notImplemented() {
    if (!this.implemented) {
      let content = `
        This feature is not implemented yet.
      `;
      let config = { content }
      this.implemented = this.#WidgetsG.insert("Dialogue", config)
      this.implemented.start()
    }
    else this.implemented.open()
  }

} // end class TradeXchart

// add global stylesheet for all charts
if (!window.customElements.get('tradex-chart')) {
  // insert global TradeX chart stylesheet
  document.head.insertAdjacentHTML("beforeend", cssVars)
  document.head.insertAdjacentHTML("beforeend", style)
  // define &lt;tradex-chart>&lt;/tradex-chart>
  window.customElements.define('tradex-chart', TradeXchart)
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Axis.html">Axis</a></li><li><a href="Colour.html">Colour</a></li><li><a href="DMI.module.exports.html">module.exports</a></li><li><a href="EMA.module.exports.html">module.exports</a></li><li><a href="Hit.html">Hit</a></li><li><a href="indicator.html">indicator</a></li><li><a href="Layer.html">Layer</a></li><li><a href="MainPane.html">MainPane</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="Node.html">Node</a></li><li><a href="RSI.html">RSI</a></li><li><a href="RSI.module.exports.html">module.exports</a></li><li><a href="ScaleBar.html">ScaleBar</a></li><li><a href="Scene.html">Scene</a></li><li><a href="StateMachine.html">StateMachine</a></li><li><a href="ToolsBar.html">ToolsBar</a></li><li><a href="TradeXchart.html">TradeXchart</a></li><li><a href="TradeXchart.module.exports.html">module.exports</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="WebWorker.html">WebWorker</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addOffChart">addOffChart</a></li><li><a href="global.html#addTool">addTool</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#binarySearchNearest">binarySearchNearest</a></li><li><a href="global.html#bRound">bRound</a></li><li><a href="global.html#calcIndicator">calcIndicator</a></li><li><a href="global.html#calcIndicatorStream">calcIndicatorStream</a></li><li><a href="global.html#calcTextWidth">calcTextWidth</a></li><li><a href="global.html#calcTimeIndex">calcTimeIndex</a></li><li><a href="global.html#CandleType">CandleType</a></li><li><a href="global.html#CHART_MINH">CHART_MINH</a></li><li><a href="global.html#checkType">checkType</a></li><li><a href="global.html#copyDeep">copyDeep</a></li><li><a href="global.html#countDigits">countDigits</a></li><li><a href="global.html#createFont">createFont</a></li><li><a href="global.html#day_start">day_start</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#decimalPlaces">decimalPlaces</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#detectInterval">detectInterval</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawTextBG">drawTextBG</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#end">end</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#firstItemInMap">firstItemInMap</a></li><li><a href="global.html#float2Int">float2Int</a></li><li><a href="global.html#get_day">get_day</a></li><li><a href="global.html#get_month">get_month</a></li><li><a href="global.html#get_year">get_year</a></li><li><a href="global.html#getPixelRatio">getPixelRatio</a></li><li><a href="global.html#getPrecision">getPrecision</a></li><li><a href="global.html#getRandom">getRandom</a></li><li><a href="global.html#getRandomInt">getRandomInt</a></li><li><a href="global.html#getRandomIntBetween">getRandomIntBetween</a></li><li><a href="global.html#getRandomIntInclusive">getRandomIntInclusive</a></li><li><a href="global.html#getTextRectHeight">getTextRectHeight</a></li><li><a href="global.html#getTextRectWidth">getTextRectWidth</a></li><li><a href="global.html#hex">hex</a></li><li><a href="global.html#hexa">hexa</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#index10">index10</a></li><li><a href="global.html#insertAtIndex">insertAtIndex</a></li><li><a href="global.html#interval2MS">interval2MS</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#isValidCandle">isValidCandle</a></li><li><a href="global.html#limit">limit</a></li><li><a href="global.html#loadState">loadState</a></li><li><a href="global.html#log10">log10</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#mergeDeep">mergeDeep</a></li><li><a href="global.html#month_start">month_start</a></li><li><a href="global.html#ms2TimeUnits">ms2TimeUnits</a></li><li><a href="global.html#nearestArrayValue">nearestArrayValue</a></li><li><a href="global.html#nice">nice</a></li><li><a href="global.html#numDigits">numDigits</a></li><li><a href="global.html#numDigits2">numDigits2</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#power">power</a></li><li><a href="global.html#precision">precision</a></li><li><a href="global.html#price2YPos">price2YPos</a></li><li><a href="global.html#refresh">refresh</a></li><li><a href="global.html#renderClosedFillPath">renderClosedFillPath</a></li><li><a href="global.html#renderClosedStrokePath">renderClosedStrokePath</a></li><li><a href="global.html#renderFilledCircle">renderFilledCircle</a></li><li><a href="global.html#renderFilledDiamond">renderFilledDiamond</a></li><li><a href="global.html#renderFilledTriangle">renderFilledTriangle</a></li><li><a href="global.html#renderFillRect">renderFillRect</a></li><li><a href="global.html#renderFillRoundRect">renderFillRoundRect</a></li><li><a href="global.html#renderHorizontalLine">renderHorizontalLine</a></li><li><a href="global.html#renderLine">renderLine</a></li><li><a href="global.html#renderPath">renderPath</a></li><li><a href="global.html#renderRoundRect">renderRoundRect</a></li><li><a href="global.html#renderStrokedCircle">renderStrokedCircle</a></li><li><a href="global.html#renderStrokeFillRoundRect">renderStrokeFillRoundRect</a></li><li><a href="global.html#renderStrokeRoundRect">renderStrokeRoundRect</a></li><li><a href="global.html#renderText">renderText</a></li><li><a href="global.html#renderVerticalLine">renderVerticalLine</a></li><li><a href="global.html#replacer">replacer</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#reviver">reviver</a></li><li><a href="global.html#round">round</a></li><li><a href="global.html#saveState">saveState</a></li><li><a href="global.html#setDimensions">setDimensions</a></li><li><a href="global.html#setHex">setHex</a></li><li><a href="global.html#setHSLA">setHSLA</a></li><li><a href="global.html#setPriceVolumePrecision">setPriceVolumePrecision</a></li><li><a href="global.html#setRGBA">setRGBA</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#throttle">throttle</a></li><li><a href="global.html#time2XPos">time2XPos</a></li><li><a href="global.html#timestampDifference">timestampDifference</a></li><li><a href="global.html#updateLegends">updateLegends</a></li><li><a href="global.html#updateRange">updateRange</a></li><li><a href="global.html#validateConfig">validateConfig</a></li><li><a href="global.html#validateShallow">validateShallow</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#weave">weave</a></li><li><a href="global.html#YAxisPosition">YAxisPosition</a></li><li><a href="global.html#YAxisType">YAxisType</a></li><li><a href="global.html#year_start">year_start</a></li><li><a href="global.html#zoomRange">zoomRange</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Mar 11 2023 22:32:46 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
