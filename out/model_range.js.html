<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: model/range.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: model/range.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// range.js

import { DAY_MS, interval2MS, ms2Interval, WEEK_MS } from "../utils/time"
import { DEFAULT_TIMEFRAMEMS, LIMITFUTURE, LIMITPAST, MINCANDLES, MAXCANDLES, YAXIS_BOUNDS } from "../definitions/chart"
import { isNumber, isObject } from "../utils/typeChecks"
import { bRound, limit } from "../utils/number"
// import WebWorker from "./webWorkers"
// import WebWorker from "./webWorkers4"

export class Range {

  data
  #interval = DEFAULT_TIMEFRAMEMS
  #intervalStr = "1s"
  indexStart = 0
  indexEnd = LIMITFUTURE
  valueMin = 0
  valueMax = 0
  valueDiff = 0
  volumeMin = 0
  volumeMax = 0
  volumeDiff = 0
  valueMinIdx = 0
  valueMaxIdx = 0
  volumeMinIdx = 0
  volumeMaxIdx = 0
  old = {}
  limitFuture = LIMITFUTURE
  limitPast = LIMITPAST
  minCandles = MINCANDLES
  maxCandles = MAXCANDLES
  yAxisBounds = YAXIS_BOUNDS
  rangeLimit = LIMITFUTURE
  anchor
  #core
  #worker
  #init = true

  constructor( allData, start=0, end=allData.data.length-1, config={}) {
    if (!isObject(allData)) return false
    if (!isObject(config)) return false
    if (!(config?.core?.constructor.name == "TradeXchart")) return false

    this.#init = true
    this.limitFuture = (isNumber(this.config?.limitFuture)) ? this.config.limitFuture : LIMITFUTURE
    this.limitPast = (isNumber(this.config?.limitPast)) ? this.config.limitPast : LIMITPAST
    this.minCandles = (isNumber(this.config?.minCandles)) ? this.config.minCandles : MINCANDLES
    this.maxCandles = (isNumber(this.config?.maxCandles)) ? this.config.maxCandles : MAXCANDLES
    this.yAxisBounds = (isNumber(this.config?.limitBounds)) ? this.config.limitBounds : YAXIS_BOUNDS
    this.#core = config.core

    const MaxMinPriceVolStr = `
    (input) => {
      return maxMinPriceVol(input)
    }
    function ${this.maxMinPriceVol.toString()}
  `
    // this.#worker = this.#core.worker.create("range", MaxMinPriceVolStr, undefined, this.#core)

    const tf = config?.interval || DEFAULT_TIMEFRAMEMS

    if (allData.data.length == 0) {
      let ts = Date.now()
      start = 0
      end = this.rangeLimit
      this.#interval = tf
      this.#intervalStr = ms2Interval(this.interval)
      this.anchor = ts - (ts % tf) // - (this.limitPast * this.#interval)
    }  
    else if (allData.data.length &lt; 2) {
      this.#interval = tf
      this.#intervalStr = ms2Interval(this.interval)
    }
    else if (end == 0 &amp;&amp; allData.data.length >= this.rangeLimit)
      end = this.rangeLimit
    else if (end == 0)
      end = allData.data.length
    
    for (let data in allData) {
      this[data] = allData[data]
    }

    if (!this.set(start, end)) return false

    if (allData.data.length > 2) {
      this.#interval = detectInterval(this.data)
      this.#intervalStr = ms2Interval(this.interval)
    }

    // for (let i of this?.offChart) {
    //   i.valueMin = 0
    //   i.valueMax = 100
    //   i.valueDiff = 100
    // }

  }

  get dataLength () { return (this.data.length == 0) ? 0 : this.data.length - 1 }
  get Length () { return this.indexEnd - this.indexStart }
  get timeDuration () { return this.timeFinish - this.timeStart }
  get timeMin () { return this.value(this.indexStart)[0] }
  get timeMax () { return this.value(this.indexEnd)[0] }
  get rangeDuration () { return this.timeMax - this.timeMin }
  get timeStart () { return this.value(0)[0] }
  get timeFinish () { return this.value(this.dataLength)[0] }
  set interval (i) { this.#interval = i }
  get interval () { return this.#interval }
  set intervalStr (i) { this.#intervalStr = i }
  get intervalStr () { return this.#intervalStr }

  end() {
    WebWorker.destroy(this.#worker.ID)
  }

  set (start=0, end=this.dataLength, max=this.maxCandles) {
    if (!isNumber(start) || 
        !isNumber(end) ||
        !isNumber(max)) return false
    // integer guard, prevent decimals
    start = Math.floor(start)
    end = Math.ceil(end)
    max = Math.ceil(max)

    // check and correct start and end argument order
    if (start > end) [start, end] = [end, start]
    // range length constraint
    end = limit(end, start + this.minCandles, start + max)
    // set out of history bounds limits
    start = limit(start, this.limitPast * -1,  this.dataLength + this.limitFuture - this.minCandles - 1)
    end = limit(end, (this.limitPast * -1) + this.minCandles + 1, this.dataLength + this.limitFuture)
  
    const newStart = start
    const newEnd = end
    const oldStart = this.indexStart
    const oldEnd = this.indexEnd
      let inOut = this.Length

    this.indexStart = start
    this.indexEnd = end

    inOut -= this.Length

    let maxMin = this.maxMinPriceVol({data: this.data, start: this.indexStart, end: this.indexEnd, that: this})
    
    this.setMaxMin(maxMin)

    // if (this.#init || this.old.priceMax != this.priceMax || this.old.priceMin != this.priceMin) {
    //   this.#core.emit("range_priceMaxMin", [this.priceMax, this.priceMin])
    // }

    this.#core.emit("setRange", [newStart, newEnd, oldStart, oldEnd])
    // this.#core.emit("chart_zoom", [newStart, newEnd, oldStart, oldEnd, inOut])
    // this.#core.emit(`chart_zoom_${inOut}`, [newStart, newEnd, oldStart, oldEnd])

    // if (this.#init) this.#init = false

    return true

    // use web worker after init
    // this.#worker.postMessage({data: this.data, start: start, end: end, that: this})
    // .then(maxMin => {
    //   this.setMaxMin(maxMin)

    //   if (this.old.priceMax != this.priceMax || this.old.priceMin != this.priceMin) {
    //     this.#core.emit("range_priceMaxMin", [this.priceMax, this.priceMin])
    //   }

    //   this.#core.emit("setRange", [newStart, newEnd, oldStart, oldEnd])
    //   this.#core.emit("chart_zoom", [newStart, newEnd, oldStart, oldEnd, inOut])
    //   this.#core.emit(`chart_zoom_${inOut}`, [newStart, newEnd, oldStart, oldEnd])
    // })
    
    // return true
  }

  setMaxMin(maxMin) {
    for (let m in maxMin) {
      this.old[m] = this[m]
      this[m] = maxMin[m]
    }
    this.scale = (this.dataLength != 0) ? this.Length / this.dataLength : 1
  }

  /**
   * 
   * @param {number} index - price history index, out of bounds will return null filled entry
   * @returns {array}
   */
  value ( index ) {
    // return last value as default
    if (!isNumber(index)) index = this.data.length - 1
  
    let v = this.data[index]
    if (v !== undefined) return v
    else {
      const len = this.data.length - 1
      v = [null, null, null, null, null, null]

      if (this.data.length &lt; 1) {
        v[0] = Date.now() + (this.interval * index)
        return v
      }
      else if (index &lt; 0) {
        v[0] = this.data[0][0] + (this.interval * index)
        return v
      }
      else if (index > len) {
        v[0] = this.data[len][0] + (this.interval * (index - len))
        return v
      }
      else return null
    }
  }

  /**
   * Return time index
   * @param {number} ts - timestamp
   * @returns {number}
   */
   getTimeIndex (ts) {
    if (!isNumber(ts)) return false
    ts = ts - (ts % this.interval)
  
    let x = (this.data.length > 0) ? this.data[0][0] : this.anchor
    if (ts === x) 
      return 0
    else if (ts &lt; x)
      return ((x - ts) / this.interval) * -1
    else 
      return (ts - x) / this.interval
  }

  /**
   * Is timestamp in current range including future and past legal bounds
   * @param {number} t - timestamp
   * @returns {boolean}
   */
  inRange(t) {
    return (t >= this.timeMin &amp;&amp; t &lt;= this.timeMax) ? true : false
  }

  /**
   * Is timestamp in current range only, excluding future and past legal bounds
   * @param {number} t 
   * @returns {boolean}
   */
  inPriceHistory (t) {
    return (t >= this.timeStart &amp;&amp; t &lt;= this.timeFinish) ? true : false
  }

  inRenderRange (t) {
    let i = this.getTimeIndex(t)
    let o = this.#core.rangeScrollOffset
    return (i >= this.indexStart - o &amp;&amp; i &lt;= this.indexEnd + o) ? true : false
  }
  
  /**
   * Return index offset of timestamp relative to range start
   * @param {number} ts - timestamp
   * @returns {number}
   */
  rangeIndex (ts) { return this.getTimeIndex(ts) - this.indexStart }

  /**
   * Find price maximum and minimum, volume maximum and minimum
   * @param {array} data
   * @param {number} [start=0]
   * @param {number} [end=data.length-1]
   * @return {object}  
   */
   maxMinPriceVol ( input ) {
// console.time()
    let {data, start, end, that} = {...input}
    let buffer = bRound(this.#core.bufferPx / this.#core.candleW)

    buffer = (isNumber(buffer)) ? buffer : 0
    start = (isNumber(start)) ? start - buffer : 0
    start = (start > 0) ? start : 0

    end = (typeof end === "number") ? end : data?.length-1

    if (data.length == 0) {
      return {
        valueMin: 0,
        valueMax: 1,
        volumeMin: 0,
        volumeMax: 0,
        valueMinIdx: 0,
        valueMaxIdx: 0,
        volumeMinIdx: 0,
        volumeMaxIdx: 0,
      }
    }
    let l = data.length - 1
    let i = limit(start, 0, l)
    let c = limit(end, 0, l)

    let valueMin  = data[i][3]
    let valueMax  = data[i][2]
    let volumeMin = data[i][5]
    let volumeMax = data[i][5]

    let valueMinIdx  = i
    let valueMaxIdx  = i
    let volumeMinIdx = i
    let volumeMaxIdx = i

    while(i++ &lt; c) {
      if (data[i][3] &lt; valueMin) {
        valueMin = data[i][3]
        valueMinIdx = i
      }
      if (data[i][2] > valueMax) {
        valueMax = data[i][2]
        valueMaxIdx = i
      }
      if (data[i][5] &lt; volumeMin) {
        volumeMin = data[i][5]
        volumeMinIdx = i
      }
      if (data[i][5] > volumeMax) {
        volumeMax = data[i][5]
        volumeMaxIdx = i
      }
    }
// console.timeEnd()
    let diff = valueMax - valueMin
    valueMin -= diff * 0.1 //that.yAxisBounds
    valueMin = (valueMin > 0) ? valueMin : 0
    valueMax += diff * 0.1 //that.yAxisBounds
    diff = valueMax - valueMin

    // valueMin *= (1 - that.yAxisBounds)
    // valueMax *= (1 + that.yAxisBounds)
    return {
      valueMin: valueMin,
      valueMax: valueMax,
      valueDiff: valueMax - valueMin,
      volumeMin: volumeMin,
      volumeMax: volumeMax,
      volumeDiff: volumeMax - volumeMin,

      valueMinIdx: valueMinIdx,
      valueMaxIdx: valueMaxIdx,
      volumeMinIdx: volumeMinIdx,
      volumeMaxIdx: volumeMaxIdx,
    }

    function limit(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }
  }

  snapshot(start, end) {
    return {
      constructor: {name: "RangeSnapshot"},
      ts: Date.now(),

      data: this.data,
      dataLength: this.dataLength,
      Length: this.Length,
      timeDuration: this.timeDuration,
      timeMin: this.timeMin,
      timeMax: this.timeMax,
      rangeDuration: this.rangeDuration,
      timeStart: this.timeStart,
      timeFinish: this.timeFinish,
      interval: this.interval,
      intervalStr: this.intervalStr 
    }
  }
} // end class


export function rangeOnchartValue( range, indicator, index ) {
  const len = range.onchart[indicator].length - 1
  const value = null
}

export function rangeOffchartValue( range, indicator, index ) {
}

export function rangeDatasetValue( range, indicator, index ) {
}

/**
 * Detects candles interval
 * @param {array} ohlcv - array of ohlcv values (price history)
 * @returns {number} - milliseconds
 */
export function detectInterval(ohlcv) {

  let len = Math.min(ohlcv.length - 1, 99)
  let min = Infinity
  ohlcv.slice(0, len).forEach((x, i) => {
      let d = ohlcv[i+1][0] - x[0]
      if (d === d &amp;&amp; d &lt; min) min = d
  })
  // This saves monthly chart from being awkward
  // if (min >= WEEK_MS * 4 &amp;&amp; min &lt;= DAY_MS * 30) {
  //     return DAY_MS * 31
  // }
  return min
}

/**
 * Calculate the index for a given time stamp
 * @param {object} time - time object provided by core
 * @param {number} timeStamp 
 * @returns {number}
 */
export function calcTimeIndex(time, timeStamp) {
  if (!isNumber(timeStamp)) return false

  let index
  let timeFrameMS = time.timeFrameMS
  timeStamp = timeStamp - (timeStamp % timeFrameMS)

  if (timeStamp === time.range.data[0][0])
    index = 0
  else if (timeStamp &lt; time.range.data[0][0]) 
    index = ((time.range.data[0][0] - timeStamp) / timeFrameMS) * -1
  else 
    index = (timeStamp - time.range.data[0][0]) / timeFrameMS

  return index
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Axis.html">Axis</a></li><li><a href="Colour.html">Colour</a></li><li><a href="DMI.module.exports.html">module.exports</a></li><li><a href="EMA.module.exports.html">module.exports</a></li><li><a href="Hit.html">Hit</a></li><li><a href="indicator.html">indicator</a></li><li><a href="Layer.html">Layer</a></li><li><a href="MainPane.html">MainPane</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="Node.html">Node</a></li><li><a href="RSI.html">RSI</a></li><li><a href="RSI.module.exports.html">module.exports</a></li><li><a href="ScaleBar.html">ScaleBar</a></li><li><a href="Scene.html">Scene</a></li><li><a href="StateMachine.html">StateMachine</a></li><li><a href="ToolsBar.html">ToolsBar</a></li><li><a href="TradeXchart.html">TradeXchart</a></li><li><a href="TradeXchart.module.exports.html">module.exports</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="WebWorker.html">WebWorker</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addOffChart">addOffChart</a></li><li><a href="global.html#addTool">addTool</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#binarySearchNearest">binarySearchNearest</a></li><li><a href="global.html#bRound">bRound</a></li><li><a href="global.html#calcIndicator">calcIndicator</a></li><li><a href="global.html#calcIndicatorStream">calcIndicatorStream</a></li><li><a href="global.html#calcTextWidth">calcTextWidth</a></li><li><a href="global.html#calcTimeIndex">calcTimeIndex</a></li><li><a href="global.html#CandleType">CandleType</a></li><li><a href="global.html#CHART_MINH">CHART_MINH</a></li><li><a href="global.html#checkType">checkType</a></li><li><a href="global.html#copyDeep">copyDeep</a></li><li><a href="global.html#countDigits">countDigits</a></li><li><a href="global.html#createFont">createFont</a></li><li><a href="global.html#day_start">day_start</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#decimalPlaces">decimalPlaces</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#detectInterval">detectInterval</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawTextBG">drawTextBG</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#end">end</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#firstItemInMap">firstItemInMap</a></li><li><a href="global.html#float2Int">float2Int</a></li><li><a href="global.html#get_day">get_day</a></li><li><a href="global.html#get_month">get_month</a></li><li><a href="global.html#get_year">get_year</a></li><li><a href="global.html#getPixelRatio">getPixelRatio</a></li><li><a href="global.html#getPrecision">getPrecision</a></li><li><a href="global.html#getRandom">getRandom</a></li><li><a href="global.html#getRandomInt">getRandomInt</a></li><li><a href="global.html#getRandomIntBetween">getRandomIntBetween</a></li><li><a href="global.html#getRandomIntInclusive">getRandomIntInclusive</a></li><li><a href="global.html#getTextRectHeight">getTextRectHeight</a></li><li><a href="global.html#getTextRectWidth">getTextRectWidth</a></li><li><a href="global.html#hex">hex</a></li><li><a href="global.html#hexa">hexa</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#index10">index10</a></li><li><a href="global.html#insertAtIndex">insertAtIndex</a></li><li><a href="global.html#interval2MS">interval2MS</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#isValidCandle">isValidCandle</a></li><li><a href="global.html#limit">limit</a></li><li><a href="global.html#loadState">loadState</a></li><li><a href="global.html#log10">log10</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#mergeDeep">mergeDeep</a></li><li><a href="global.html#month_start">month_start</a></li><li><a href="global.html#ms2TimeUnits">ms2TimeUnits</a></li><li><a href="global.html#nearestArrayValue">nearestArrayValue</a></li><li><a href="global.html#nice">nice</a></li><li><a href="global.html#numDigits">numDigits</a></li><li><a href="global.html#numDigits2">numDigits2</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#power">power</a></li><li><a href="global.html#precision">precision</a></li><li><a href="global.html#price2YPos">price2YPos</a></li><li><a href="global.html#refresh">refresh</a></li><li><a href="global.html#renderClosedFillPath">renderClosedFillPath</a></li><li><a href="global.html#renderClosedStrokePath">renderClosedStrokePath</a></li><li><a href="global.html#renderFilledCircle">renderFilledCircle</a></li><li><a href="global.html#renderFilledDiamond">renderFilledDiamond</a></li><li><a href="global.html#renderFilledTriangle">renderFilledTriangle</a></li><li><a href="global.html#renderFillRect">renderFillRect</a></li><li><a href="global.html#renderFillRoundRect">renderFillRoundRect</a></li><li><a href="global.html#renderHorizontalLine">renderHorizontalLine</a></li><li><a href="global.html#renderLine">renderLine</a></li><li><a href="global.html#renderPath">renderPath</a></li><li><a href="global.html#renderRoundRect">renderRoundRect</a></li><li><a href="global.html#renderStrokedCircle">renderStrokedCircle</a></li><li><a href="global.html#renderStrokeFillRoundRect">renderStrokeFillRoundRect</a></li><li><a href="global.html#renderStrokeRoundRect">renderStrokeRoundRect</a></li><li><a href="global.html#renderText">renderText</a></li><li><a href="global.html#renderVerticalLine">renderVerticalLine</a></li><li><a href="global.html#replacer">replacer</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#reviver">reviver</a></li><li><a href="global.html#round">round</a></li><li><a href="global.html#saveState">saveState</a></li><li><a href="global.html#setDimensions">setDimensions</a></li><li><a href="global.html#setHex">setHex</a></li><li><a href="global.html#setHSLA">setHSLA</a></li><li><a href="global.html#setPriceVolumePrecision">setPriceVolumePrecision</a></li><li><a href="global.html#setRGBA">setRGBA</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#throttle">throttle</a></li><li><a href="global.html#time2XPos">time2XPos</a></li><li><a href="global.html#timestampDifference">timestampDifference</a></li><li><a href="global.html#updateLegends">updateLegends</a></li><li><a href="global.html#updateRange">updateRange</a></li><li><a href="global.html#validateConfig">validateConfig</a></li><li><a href="global.html#validateShallow">validateShallow</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#weave">weave</a></li><li><a href="global.html#YAxisPosition">YAxisPosition</a></li><li><a href="global.html#YAxisType">YAxisType</a></li><li><a href="global.html#year_start">year_start</a></li><li><a href="global.html#zoomRange">zoomRange</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Mar 11 2023 22:32:46 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
